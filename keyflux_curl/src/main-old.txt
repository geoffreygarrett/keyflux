
use anyhow::Result;
use std::convert::TryInto;
use std::convert::Into;
use std::convert::From;
use std::str::FromStr;
use curl_parser::ParsedRequest;

// impl From<curl_parser::ParsedRequest> for reqwest::RequestBuilder {
//     fn from(mut parsed: curl_parser::ParsedRequest) -> Self {
//         let client = reqwest::Client::new();
//         let mut req = client.request(parsed.method(), parsed.url().to_string());
//
//         for (key, value) in parsed.headers() {
//             req = req.header(key, value);
//         }
//
//         if let Some(body) = parsed.body() {
//             req = req.body(body.to_string()); // Assuming body needs to be a String
//         }
//
//         req
//     }
// }

fn main() -> Result<()> {
    let input = r#"curl -X PUT "https://api.example.com/v1/users/123" \
     -u "username:password" \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "X-Custom-Header: 12345" \
     -H "X-Request-ID: abcde-12345-fghij" \
     -b "cookiefile.txt" \
     -c "newcookiefile.txt" \
     -L \
     -d '{
           "firstName": "John",
           "lastName": "Doe",
           "email": "john.doe@example.com",
           "roles": ["admin", "user"],
           "settings": {
             "notifications": true,
             "theme": "dark"
           }
         }' \
     -o response.json \
     -v"#;
    let context: Option<serde_json::Value> = None;
    let parsed = curl_parser::ParsedRequest::load(input, context)?;
    println!("{:#?}", parsed);
    // let req: reqwest::RequestBuilder = parsed.into();
    // println!("{:#?}", req);
    Ok(())
}