/*
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`codespaces_slash_add_repository_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashAddRepositoryForSecretForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_add_selected_repo_to_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashAddSelectedRepoToOrgSecretError {
    Status404(crate::models::BasicError),
    Status409(),
    Status422(crate::models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_check_permissions_for_devcontainer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCheckPermissionsForDevcontainerError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    Status503(crate::models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_codespace_machines_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCodespaceMachinesForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status503(crate::models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_or_update_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateOrUpdateOrgSecretError {
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_or_update_repo_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateOrUpdateRepoSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_or_update_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateOrUpdateSecretForAuthenticatedUserError {
    Status422(crate::models::ValidationError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_with_pr_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateWithPrForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status503(crate::models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_create_with_repo_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashCreateWithRepoForAuthenticatedUserError {
    Status400(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status503(crate::models::SecretScanningListAlertsForEnterprise503Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_codespaces_access_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteCodespacesAccessUsersError {
    Status400(),
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_from_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteFromOrganizationError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteOrgSecretError {
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_repo_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteRepoSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_delete_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashDeleteSecretForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_export_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashExportForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_codespaces_for_user_in_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetCodespacesForUserInOrgError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_export_details_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetExportDetailsForAuthenticatedUserError {
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_org_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetOrgPublicKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetOrgSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_public_key_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetPublicKeyForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_repo_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetRepoPublicKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_repo_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetRepoSecretError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_get_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashGetSecretForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_devcontainers_in_repository_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListDevcontainersInRepositoryForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status400(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_in_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListInOrganizationError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_in_repository_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListInRepositoryForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_org_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListOrgSecretsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_repo_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListRepoSecretsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_repositories_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListRepositoriesForSecretForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_secrets_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListSecretsForAuthenticatedUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_list_selected_repos_for_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashListSelectedReposForOrgSecretError {
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_pre_flight_with_repo_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashPreFlightWithRepoForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_publish_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashPublishForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_remove_repository_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashRemoveRepositoryForSecretForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_remove_selected_repo_from_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashRemoveSelectedRepoFromOrgSecretError {
    Status404(crate::models::BasicError),
    Status409(),
    Status422(crate::models::ValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_repo_machines_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashRepoMachinesForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_codespaces_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetCodespacesAccessError {
    Status400(),
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_codespaces_access_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetCodespacesAccessUsersError {
    Status400(),
    Status404(crate::models::BasicError),
    Status422(crate::models::ValidationError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_repositories_for_secret_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetRepositoriesForSecretForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status500(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_set_selected_repos_for_org_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashSetSelectedReposForOrgSecretError {
    Status404(crate::models::BasicError),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_start_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashStartForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status400(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status402(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    Status409(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_stop_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashStopForAuthenticatedUserError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_stop_in_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashStopInOrganizationError {
    Status500(crate::models::BasicError),
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`codespaces_slash_update_for_authenticated_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodespacesSlashUpdateForAuthenticatedUserError {
    Status401(crate::models::BasicError),
    Status403(crate::models::BasicError),
    Status404(crate::models::BasicError),
    UnknownValue(serde_json::Value),
}


/// Adds a repository to the selected repositories for a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_add_repository_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashAddRepositoryForSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories/{repository_id}", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name), repository_id=repository_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashAddRepositoryForSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Adds a repository to an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret). OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_add_selected_repo_to_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashAddSelectedRepoToOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name), repository_id=repository_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashAddSelectedRepoToOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Checks whether the permissions defined by a given devcontainer configuration have been accepted by the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_check_permissions_for_devcontainer(configuration: &configuration::Configuration, owner: &str, repo: &str, r#ref: &str, devcontainer_path: &str) -> Result<crate::models::CodespacesPermissionsCheckForDevcontainer, Error<CodespacesSlashCheckPermissionsForDevcontainerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/permissions_check", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ref", &r#ref.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("devcontainer_path", &devcontainer_path.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCheckPermissionsForDevcontainerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List the machine types a codespace can transition to use.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_codespace_machines_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<crate::models::CodespacesRepoMachinesForAuthenticatedUser200Response, Error<CodespacesSlashCodespaceMachinesForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}/machines", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCodespaceMachinesForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new codespace, owned by the authenticated user.  This endpoint requires either a `repository_id` OR a `pull_request` but not both.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_create_for_authenticated_user(configuration: &configuration::Configuration, codespaces_create_for_authenticated_user_request: crate::models::CodespacesCreateForAuthenticatedUserRequest) -> Result<crate::models::Codespace, Error<CodespacesSlashCreateForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_create_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCreateForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates or updates an organization development environment secret with an encrypted value. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see \"[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api).\"  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_create_or_update_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, codespaces_create_or_update_org_secret_request: crate::models::CodespacesCreateOrUpdateOrgSecretRequest) -> Result<serde_json::Value, Error<CodespacesSlashCreateOrUpdateOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_create_or_update_org_secret_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCreateOrUpdateOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates or updates a repository development environment secret with an encrypted value. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see \"[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api).\"  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_create_or_update_repo_secret(configuration: &configuration::Configuration, owner: &str, repo: &str, secret_name: &str, codespaces_create_or_update_repo_secret_request: crate::models::CodespacesCreateOrUpdateRepoSecretRequest) -> Result<serde_json::Value, Error<CodespacesSlashCreateOrUpdateRepoSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_create_or_update_repo_secret_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCreateOrUpdateRepoSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates or updates a development environment secret for a user's codespace with an encrypted value. Encrypt your secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see \"[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api).\"  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_create_or_update_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, codespaces_create_or_update_secret_for_authenticated_user_request: crate::models::CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest) -> Result<serde_json::Value, Error<CodespacesSlashCreateOrUpdateSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_create_or_update_secret_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCreateOrUpdateSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a codespace owned by the authenticated user for the specified pull request.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_create_with_pr_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, pull_number: i32, codespaces_create_with_pr_for_authenticated_user_request: Option<crate::models::CodespacesCreateWithPrForAuthenticatedUserRequest>) -> Result<crate::models::Codespace, Error<CodespacesSlashCreateWithPrForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/pulls/{pull_number}/codespaces", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo), pull_number=pull_number);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_create_with_pr_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCreateWithPrForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a codespace owned by the authenticated user in the specified repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_create_with_repo_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, codespaces_create_with_repo_for_authenticated_user_request: Option<crate::models::CodespacesCreateWithRepoForAuthenticatedUserRequest>) -> Result<crate::models::Codespace, Error<CodespacesSlashCreateWithRepoForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_create_with_repo_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashCreateWithRepoForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Codespaces for the specified users will no longer be billed to the organization.  To use this endpoint, the access settings for the organization must be set to `selected_members`. For information on how to change this setting, see \"[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces).\"  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_delete_codespaces_access_users(configuration: &configuration::Configuration, org: &str, codespaces_delete_codespaces_access_users_request: crate::models::CodespacesDeleteCodespacesAccessUsersRequest) -> Result<(), Error<CodespacesSlashDeleteCodespacesAccessUsersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/access/selected_users", local_var_configuration.base_path, org=crate::apis::urlencode(org));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_delete_codespaces_access_users_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashDeleteCodespacesAccessUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_delete_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<serde_json::Value, Error<CodespacesSlashDeleteForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashDeleteForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_delete_from_organization(configuration: &configuration::Configuration, org: &str, username: &str, codespace_name: &str) -> Result<serde_json::Value, Error<CodespacesSlashDeleteFromOrganizationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/members/{username}/codespaces/{codespace_name}", local_var_configuration.base_path, org=crate::apis::urlencode(org), username=crate::apis::urlencode(username), codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashDeleteFromOrganizationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an organization development environment secret using the secret name.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_delete_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str) -> Result<(), Error<CodespacesSlashDeleteOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashDeleteOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a development environment secret in a repository using the secret name.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_delete_repo_secret(configuration: &configuration::Configuration, owner: &str, repo: &str, secret_name: &str) -> Result<(), Error<CodespacesSlashDeleteRepoSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashDeleteRepoSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a development environment secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_delete_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str) -> Result<(), Error<CodespacesSlashDeleteSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashDeleteSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.  If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_export_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<crate::models::CodespaceExportDetails, Error<CodespacesSlashExportForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}/exports", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashExportForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the codespaces that a member of an organization has for repositories in that organization.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_get_codespaces_for_user_in_org(configuration: &configuration::Configuration, org: &str, username: &str, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListInOrganization200Response, Error<CodespacesSlashGetCodespacesForUserInOrgError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/members/{username}/codespaces", local_var_configuration.base_path, org=crate::apis::urlencode(org), username=crate::apis::urlencode(username));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetCodespacesForUserInOrgError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets information about an export of a codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_get_export_details_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str, export_id: &str) -> Result<crate::models::CodespaceExportDetails, Error<CodespacesSlashGetExportDetailsForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}/exports/{export_id}", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name), export_id=crate::apis::urlencode(export_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetExportDetailsForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets information about a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_get_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<crate::models::Codespace, Error<CodespacesSlashGetForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets. OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_get_org_public_key(configuration: &configuration::Configuration, org: &str) -> Result<crate::models::CodespacesPublicKey, Error<CodespacesSlashGetOrgPublicKeyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/public-key", local_var_configuration.base_path, org=crate::apis::urlencode(org));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetOrgPublicKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets an organization development environment secret without revealing its encrypted value.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_get_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str) -> Result<crate::models::CodespacesOrgSecret, Error<CodespacesSlashGetOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_get_public_key_for_authenticated_user(configuration: &configuration::Configuration, ) -> Result<crate::models::CodespacesUserPublicKey, Error<CodespacesSlashGetPublicKeyForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/public-key", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetPublicKeyForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.  Anyone with read access to the repository can use this endpoint.  If the repository is private, OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_get_repo_public_key(configuration: &configuration::Configuration, owner: &str, repo: &str) -> Result<crate::models::CodespacesPublicKey, Error<CodespacesSlashGetRepoPublicKeyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/public-key", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetRepoPublicKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a single repository development environment secret without revealing its encrypted value.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_get_repo_secret(configuration: &configuration::Configuration, owner: &str, repo: &str, secret_name: &str) -> Result<crate::models::RepoCodespacesSecret, Error<CodespacesSlashGetRepoSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetRepoSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a development environment secret available to a user's codespaces without revealing its encrypted value.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_get_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str) -> Result<crate::models::CodespacesSecret, Error<CodespacesSlashGetSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashGetSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files specify launchpoint configurations for codespaces created within the repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_list_devcontainers_in_repository_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListDevcontainersInRepositoryForAuthenticatedUser200Response, Error<CodespacesSlashListDevcontainersInRepositoryForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/devcontainers", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListDevcontainersInRepositoryForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the authenticated user's codespaces.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_list_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>, repository_id: Option<i32>) -> Result<crate::models::CodespacesListInOrganization200Response, Error<CodespacesSlashListForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = repository_id {
        local_var_req_builder = local_var_req_builder.query(&[("repository_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the codespaces associated to a specified organization.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_list_in_organization(configuration: &configuration::Configuration, org: &str, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListInOrganization200Response, Error<CodespacesSlashListInOrganizationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces", local_var_configuration.base_path, org=crate::apis::urlencode(org));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListInOrganizationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists the codespaces associated to a specified repository and the authenticated user.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_list_in_repository_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListInOrganization200Response, Error<CodespacesSlashListInRepositoryForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListInRepositoryForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all Codespaces development environment secrets available at the organization-level without revealing their encrypted values.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_list_org_secrets(configuration: &configuration::Configuration, org: &str, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListOrgSecrets200Response, Error<CodespacesSlashListOrgSecretsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets", local_var_configuration.base_path, org=crate::apis::urlencode(org));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListOrgSecretsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all development environment secrets available in a repository without revealing their encrypted values.  OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
pub async fn codespaces_slash_list_repo_secrets(configuration: &configuration::Configuration, owner: &str, repo: &str, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListRepoSecrets200Response, Error<CodespacesSlashListRepoSecretsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/secrets", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListRepoSecretsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List the repositories that have been granted the ability to use a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_list_repositories_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str) -> Result<crate::models::ActionsListSelectedReposForOrgSecret200Response, Error<CodespacesSlashListRepositoriesForSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListRepositoriesForSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all development environment secrets available for a user's codespaces without revealing their encrypted values.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_list_secrets_for_authenticated_user(configuration: &configuration::Configuration, per_page: Option<i32>, page: Option<i32>) -> Result<crate::models::CodespacesListSecretsForAuthenticatedUser200Response, Error<CodespacesSlashListSecretsForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListSecretsForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_list_selected_repos_for_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, page: Option<i32>, per_page: Option<i32>) -> Result<crate::models::ActionsListSelectedReposForOrgSecret200Response, Error<CodespacesSlashListSelectedReposForOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashListSelectedReposForOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the default attributes for codespaces created by the user with the repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_pre_flight_with_repo_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, r#ref: Option<&str>, client_ip: Option<&str>) -> Result<crate::models::CodespacesPreFlightWithRepoForAuthenticatedUser200Response, Error<CodespacesSlashPreFlightWithRepoForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/new", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = r#ref {
        local_var_req_builder = local_var_req_builder.query(&[("ref", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = client_ip {
        local_var_req_builder = local_var_req_builder.query(&[("client_ip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashPreFlightWithRepoForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Publishes an unpublished codespace, creating a new repository and assigning it to the codespace.  The codespace's token is granted write permissions to the repository, allowing the user to push their changes.  This will fail for a codespace that is already published, meaning it has an associated repository.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_publish_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str, codespaces_publish_for_authenticated_user_request: crate::models::CodespacesPublishForAuthenticatedUserRequest) -> Result<crate::models::CodespaceWithFullRepository, Error<CodespacesSlashPublishForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}/publish", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_publish_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashPublishForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a repository from the selected repositories for a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_remove_repository_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashRemoveRepositoryForSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories/{repository_id}", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name), repository_id=repository_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashRemoveRepositoryForSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a repository from an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_remove_selected_repo_from_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, repository_id: i32) -> Result<(), Error<CodespacesSlashRemoveSelectedRepoFromOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name), repository_id=repository_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashRemoveSelectedRepoFromOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List the machine types available for a given repository based on its configuration.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_repo_machines_for_authenticated_user(configuration: &configuration::Configuration, owner: &str, repo: &str, location: Option<&str>, client_ip: Option<&str>, r#ref: Option<&str>) -> Result<crate::models::CodespacesRepoMachinesForAuthenticatedUser200Response, Error<CodespacesSlashRepoMachinesForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/repos/{owner}/{repo}/codespaces/machines", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), repo=crate::apis::urlencode(repo));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = client_ip {
        local_var_req_builder = local_var_req_builder.query(&[("client_ip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#ref {
        local_var_req_builder = local_var_req_builder.query(&[("ref", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashRepoMachinesForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces access permissions for users according to the visibility. OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_set_codespaces_access(configuration: &configuration::Configuration, org: &str, codespaces_set_codespaces_access_request: crate::models::CodespacesSetCodespacesAccessRequest) -> Result<(), Error<CodespacesSlashSetCodespacesAccessError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/access", local_var_configuration.base_path, org=crate::apis::urlencode(org));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_set_codespaces_access_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashSetCodespacesAccessError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Codespaces for the specified users will be billed to the organization.  To use this endpoint, the access settings for the organization must be set to `selected_members`. For information on how to change this setting, see \"[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces).\"  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_set_codespaces_access_users(configuration: &configuration::Configuration, org: &str, codespaces_set_codespaces_access_users_request: crate::models::CodespacesSetCodespacesAccessUsersRequest) -> Result<(), Error<CodespacesSlashSetCodespacesAccessUsersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/access/selected_users", local_var_configuration.base_path, org=crate::apis::urlencode(org));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_set_codespaces_access_users_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashSetCodespacesAccessUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Select the repositories that will use a user's development environment secret.  The authenticated user must have Codespaces access to use this endpoint.  OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
pub async fn codespaces_slash_set_repositories_for_secret_for_authenticated_user(configuration: &configuration::Configuration, secret_name: &str, codespaces_set_repositories_for_secret_for_authenticated_user_request: crate::models::CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest) -> Result<(), Error<CodespacesSlashSetRepositoriesForSecretForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/secrets/{secret_name}/repositories", local_var_configuration.base_path, secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_set_repositories_for_secret_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashSetRepositoriesForSecretForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Replaces all repositories for an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_set_selected_repos_for_org_secret(configuration: &configuration::Configuration, org: &str, secret_name: &str, codespaces_set_selected_repos_for_org_secret_request: crate::models::CodespacesSetSelectedReposForOrgSecretRequest) -> Result<(), Error<CodespacesSlashSetSelectedReposForOrgSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/codespaces/secrets/{secret_name}/repositories", local_var_configuration.base_path, org=crate::apis::urlencode(org), secret_name=crate::apis::urlencode(secret_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_set_selected_repos_for_org_secret_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CodespacesSlashSetSelectedReposForOrgSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Starts a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_start_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<crate::models::Codespace, Error<CodespacesSlashStartForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}/start", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashStartForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stops a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_stop_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str) -> Result<crate::models::Codespace, Error<CodespacesSlashStopForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}/stop", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashStopForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stops a user's codespace.  OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
pub async fn codespaces_slash_stop_in_organization(configuration: &configuration::Configuration, org: &str, username: &str, codespace_name: &str) -> Result<crate::models::Codespace, Error<CodespacesSlashStopInOrganizationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/orgs/{org}/members/{username}/codespaces/{codespace_name}/stop", local_var_configuration.base_path, org=crate::apis::urlencode(org), username=crate::apis::urlencode(username), codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashStopInOrganizationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.  If you specify a new machine type it will be applied the next time your codespace is started.  OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
pub async fn codespaces_slash_update_for_authenticated_user(configuration: &configuration::Configuration, codespace_name: &str, codespaces_update_for_authenticated_user_request: Option<crate::models::CodespacesUpdateForAuthenticatedUserRequest>) -> Result<crate::models::Codespace, Error<CodespacesSlashUpdateForAuthenticatedUserError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/user/codespaces/{codespace_name}", local_var_configuration.base_path, codespace_name=crate::apis::urlencode(codespace_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&codespaces_update_for_authenticated_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CodespacesSlashUpdateForAuthenticatedUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

