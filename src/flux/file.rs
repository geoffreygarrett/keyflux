use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json;
use serde_yaml;
use toml;
use std::fs::{OpenOptions};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::collections::HashMap;
use chrono::Utc;
use log::{error, info};
use crate::error::FluxError;
use crate::file::format_manager::FormatManager;
use crate::file::key_collection::{KeyCollection, KeyCollectionTransform};
use crate::traits::Flux;
use crate::key::Key;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FileAttributes {
    pub format: Option<String>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct FileFlux {
    pub path: PathBuf,
    pub format: String,
    pub args: Option<FileAttributes>,
}

impl FileFlux {
    // fn ensure_file_exists_and_valid(&self) -> Result<(), FluxError> {
    //     let path = Path::new(&self.path);
    //     if let Some(parent) = path.parent() {
    //         std::fs::create_dir_all(parent)?; // Create nested directories if they do not exist
    //     }
    //     if !path.exists() {
    //         let mut file = OpenOptions::new().create(true).write(true).open(&self.path)?;
    //         // Initialize the file with an empty but valid content for each format
    //         match self.format.as_ref() {
    //             "json" => writeln!(file, "{{}}")?,
    //             "yaml" => writeln!(file, "")?, // Initialize with an empty map
    //             "toml" => writeln!(file, "")?,       // TOML can start empty
    //             "env" => writeln!(file, "")?,        // ENV can start empty
    //             _ => return Err(FluxError::UnsupportedFormat("Unsupported file format".to_string())),
    //         };
    //     }
    //     Ok(())
    // }

    // fn load_existing_keys(&self) -> Result<HashMap<String, String>, FluxError> {
    //     self.ensure_file_exists_and_valid()?;
    //     let mut file = OpenOptions::new().read(true).open(&self.path)?;
    //     let mut contents = String::new();
    //     file.read_to_string(&mut contents)?;
    //     if contents.trim().is_empty() {
    //         return Ok(HashMap::new());  // Return an empty map if the file is empty
    //     }
    //
    //     match self.format.as_ref() {
    //         "json" => serde_json::from_str(&contents).map_err(FluxError::from),
    //         "yaml" => serde_yaml::from_str(&contents).map_err(FluxError::from),
    //         "toml" => toml::from_str(&contents).map_err(FluxError::from),
    //         "env" => {
    //             let map = contents
    //                 .lines()
    //                 .filter_map(|line| {
    //                     let parts: Vec<&str> = line.splitn(2, '=').collect();
    //                     if parts.len() == 2 {
    //                         Some((parts[0].to_string(), parts[1].to_string()))
    //                     } else {
    //                         None
    //                     }
    //                 })
    //                 .collect();
    //             Ok(map)
    //         }
    //         _ => Err(FluxError::UnsupportedFormat("Unsupported file format".to_string())),
    //     }
    // }

    // async fn load_existing_keys(&self) -> Result<KeyCollection, FluxError> {
    //     let manager = FormatManager::instance_read().await;
    //     manager.load_keys(&self.path, Some(&self.format))
    // }

    async fn save_keys(&self, keys: &KeyCollection) -> Result<(), FluxError> {
        // let date = Utc::now();
        // let package_name = env!("CARGO_PKG_NAME");
        // let package_version = env!("CARGO_PKG_VERSION");
        // let autogenerated_info = format!(
        //     "# AUTOGENERATED BY {} V{} ON {}. DO NOT EDIT.\n",
        //     package_name.to_uppercase(),
        //     package_version,
        //     date.to_rfc3339()
        // );

        let manager = FormatManager::read().await;
        manager.save_keys(&self.path, keys, Some(&self.format))?;
        // let contents = match self.format.as_ref() {
        //     "json" => {
        //         let meta_path = format!("{}.meta", self.path.display());
        //         let mut meta_file = OpenOptions::new().create(true).write(true).truncate(true).open(&meta_path)?;
        //         writeln!(
        //             meta_file,
        //             "AUTOGENERATED BY {} V{} ON {}.\nDO NOT EDIT.\n",
        //             package_name.to_uppercase(),
        //             package_version,
        //             date.to_rfc3339()
        //         )?;
        //         serde_json::to_string_pretty(keys)?
        //     }
        //     "yaml" => {
        //         let mut result = autogenerated_info.clone();
        //         result.push_str(&serde_yaml::to_string(keys)?);
        //         result
        //     }
        //     "toml" => {
        //         let mut result = autogenerated_info.clone();
        //         result.push_str(&toml::to_string_pretty(keys)?);
        //         result
        //     }
        //     "env" => {
        //         let mut result = autogenerated_info.clone();
        //         result.push_str(&keys.iter().map(|(k, v)| format!("{}={}", k, v.value())).collect::<Vec<_>>().join("\n"));
        //         result
        //     }
        //     _ => return Err(FluxError::UnsupportedFormat("Unsupported file format".to_string())),
        // };
        //
        // let mut file = OpenOptions::new().write(true).truncate(true).open(&self.path)?;
        // file.write_all(contents.as_bytes())?;
        Ok(())
    }
}

#[async_trait]
impl Flux for FileFlux {
    async fn initialize(&self) -> Result<(), FluxError> {
        // self.ensure_file_exists_and_valid()?;
        Ok(())
    }

    async fn finalize(&self) -> Result<(), FluxError> {
        // Any cleanup logic if needed
        Ok(())
    }

    async fn single(&self, key: &Key) -> Result<(), FluxError> {
        // let mut existing_keys = self.load_existing_keys().await?; // Await the future here
        let manager = FormatManager::read().await;
        let mut keys = manager.load_keys(&self.path, Some(&self.format))?;
        keys.upsert(key.clone());
        self.save_keys(&keys).await
    }

    async fn batch(&self, keys: &KeyCollection) -> Result<(), FluxError> {
        let manager = FormatManager::read().await;
        let mut existing_keys = manager.load_keys(&self.path, Some(&self.format))?;
        // FIXME: Need another way of managing key structure types, this is breaking.
        let mut new_keys =  existing_keys.to_key_detail_collection();
        // error!("{:?} existing keys ", new_keys);
        // error!("{:?} keys ", keys);
        keys.to_key_detail_collection().iter().for_each(|key| {
            new_keys.upsert(key.clone());
        });
        // info!("{:?} keys ", new_keys);
        new_keys.sort_by();
        self.save_keys(&new_keys).await
    }

    async fn check(&self, _key: &Key) -> Result<Option<String>, FluxError> {
        Ok(None)
    }

    async fn revert(&self, _key: &Key) -> Result<(), FluxError> {
        Ok(())
    }
}
