use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json;
use serde_yaml;
use toml;
use std::fs::{OpenOptions};
use std::io::{Read, Write};
use std::path::Path;
use std::collections::HashMap;
use chrono::Utc;
use crate::error::FluxError;
use crate::traits::Flux;
use crate::key::Key;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FileAttributes {
    pub format: Option<String>,
    pub path: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct FileFlux {
    pub path: String,
    pub format: String,
    pub args: Option<FileAttributes>,
}

impl FileFlux {
    fn ensure_file_exists_and_valid(&self) -> Result<(), FluxError> {
        let path = Path::new(&self.path);
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?; // Create nested directories if they do not exist
        }
        if !path.exists() {
            let mut file = OpenOptions::new().create(true).write(true).open(&self.path)?;
            // Initialize the file with an empty but valid content for each format
            match self.format.as_ref() {
                "json" => writeln!(file, "{{}}")?,
                "yaml" => writeln!(file, "")?, // Initialize with an empty map
                "toml" => writeln!(file, "")?,       // TOML can start empty
                "env" => writeln!(file, "")?,        // ENV can start empty
                _ => return Err(FluxError::UnsupportedFormat("Unsupported file format".to_string())),
            };
        }
        Ok(())
    }

    fn load_existing_keys(&self) -> Result<HashMap<String, String>, FluxError> {
        self.ensure_file_exists_and_valid()?;
        let mut file = OpenOptions::new().read(true).open(&self.path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.trim().is_empty() {
            return Ok(HashMap::new());  // Return an empty map if the file is empty
        }

        match self.format.as_ref() {
            "json" => serde_json::from_str(&contents).map_err(FluxError::from),
            "yaml" => serde_yaml::from_str(&contents).map_err(FluxError::from),
            "toml" => toml::from_str(&contents).map_err(FluxError::from),
            "env" => {
                let map = contents
                    .lines()
                    .filter_map(|line| {
                        let parts: Vec<&str> = line.splitn(2, '=').collect();
                        if parts.len() == 2 {
                            Some((parts[0].to_string(), parts[1].to_string()))
                        } else {
                            None
                        }
                    })
                    .collect();
                Ok(map)
            }
            _ => Err(FluxError::UnsupportedFormat("Unsupported file format".to_string())),
        }
    }

    fn save_keys(&self, keys: &HashMap<String, String>) -> Result<(), FluxError> {
        let date = Utc::now();
        let package_name = env!("CARGO_PKG_NAME");
        let package_version = env!("CARGO_PKG_VERSION");
        let autogenerated_info = format!(
            "# AUTOGENERATED BY {} V{} ON {}. DO NOT EDIT.\n",
            package_name.to_uppercase(),
            package_version,
            date.to_rfc3339()
        );

        let contents = match self.format.as_ref() {
            "json" => {
                let meta_path = format!("{}.meta", self.path);
                let mut meta_file = OpenOptions::new().create(true).write(true).truncate(true).open(&meta_path)?;
                writeln!(
                    meta_file,
                    "AUTOGENERATED BY {} V{} ON {}.\nDO NOT EDIT.\n",
                    package_name.to_uppercase(),
                    package_version,
                    date.to_rfc3339()
                )?;
                serde_json::to_string_pretty(keys)?
            }
            "yaml" => {
                let mut result = autogenerated_info.clone();
                result.push_str(&serde_yaml::to_string(keys)?);
                result
            }
            "toml" => {
                let mut result = autogenerated_info.clone();
                result.push_str(&toml::to_string_pretty(keys)?);
                result
            }
            "env" => {
                let mut result = autogenerated_info.clone();
                result.push_str(&keys.iter().map(|(k, v)| format!("{}={}", k, v)).collect::<Vec<_>>().join("\n"));
                result
            }
            _ => return Err(FluxError::UnsupportedFormat("Unsupported file format".to_string())),
        };

        let mut file = OpenOptions::new().write(true).truncate(true).open(&self.path)?;
        file.write_all(contents.as_bytes())?;
        Ok(())
    }
}

#[async_trait]
impl Flux for FileFlux {
    async fn initialize(&self) -> Result<(), FluxError> {
        self.ensure_file_exists_and_valid()?;
        Ok(())
    }

    async fn finalize(&self) -> Result<(), FluxError> {
        // Any cleanup logic if needed
        Ok(())
    }

    async fn single(&self, key: &Key) -> Result<(), FluxError> {
        let mut existing_keys = self.load_existing_keys()?;
        existing_keys.insert(key.name.to_string(), key.value.to_string());
        self.save_keys(&existing_keys)
    }

    async fn batch(&self, keys: &[Key]) -> Result<(), FluxError> {
        let mut existing_keys = self.load_existing_keys()?;
        for key in keys {
            existing_keys.insert(key.name.to_string(), key.value.to_string());
        }
        self.save_keys(&existing_keys)
    }

    async fn check(&self, _key: &Key) -> Result<Option<String>, FluxError> {
        Ok(None)
    }

    async fn revert(&self, _key: &Key) -> Result<(), FluxError> {
        Ok(())
    }
}
