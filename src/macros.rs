/// A macro to register all flux types with the global flux registry.
///
/// This macro accepts a list of flux type identifiers, each representing a
/// flux type that implements the `Flux` trait. It generates a function
/// `register_all_flux_types` which registers each flux type with the global
/// flux registry.
///
/// # Examples
///
/// ```
/// use keyflux::flux::FLUX_REGISTRY;
/// flux!(GitHubAction, FileAction, SupabaseSecretsAction, VercelEnvironmentSync);
///
/// fn main() {
///     // Register all flux types
///     register_all_flux_types();
///
///     // Example dynamic configuration for a flux type
///     let config = serde_json::json!({
///         "type": "vercel_environment",
///         "id_or_name": "my_project",
///         "token": "my_vercel_token"
///     });
///
///     match create_flux_instance(&config) {
///         Ok(flux_instance) => {
///             // Use the flux_instance
///         }
///         Err(err) => {
///             eprintln!("Error creating flux instance: {:?}", err);
///         }
///     }
/// }
///
/// fn create_flux_instance(config: &serde_json::Value) -> Result<Box<dyn Flux>, ConfigError> {
///     let flux_type = config.get("type").and_then(serde_json::Value::as_str).ok_or(ConfigError::InvalidConfig)?;
///     let registry = FLUX_REGISTRY.lock().unwrap();
///     registry.create(flux_type, config)
/// }
/// ```
#[macro_export]
macro_rules! flux {
    ($($flux_type:ident),*) => {
        /// Registers all flux types with the global flux registry.
        ///
        /// This function is generated by the `flux!` macro and should be called
        /// at the start of your application to ensure all flux types are registered
        /// and available for use.
        pub fn register_all_flux_types() {
            let mut registry = FLUX_REGISTRY.lock().unwrap();
            $(
                registry.register(stringify!($flux_type), Box::new(|config| {
                    serde_json::from_value(config.clone())
                        .map(|action: $flux_type| Box::new(action) as Box<dyn Flux>)
                        .map_err(ConfigError::from)
                }));
            )*
        }
    };
}

#[macro_export]
macro_rules! register_fluxes {
    ($flux_registry:expr, { $( $name:literal => $flux_type:ty ),* $(,)? }) => {
        {
            let mut registry = $flux_registry.lock().unwrap();
            $(
                registry.register($name, Box::new(|config| {
                    let flux: $flux_type = serde_json::from_value(config.clone())
                        .map_err(|e| ConfigError::InvalidConfig(format!("Error parsing {}: {:?}", stringify!($flux_type), e)))?;
                    Ok(Box::new(flux))
                }));
            )*
        } // The lock is automatically released here
    };
}


